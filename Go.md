# Go

# 入门

1. Go语言的代码通过包组织
2. 编译器会主动把特定符号后的换行符换成分号
3. Go左闭右开
4. ++i, --i非法
5. for, if中左大括号必须在同一行
6. for循环的三个部分initialization; condition; post每个都可以省略，如果省略 initialization 和 post ，分号也可以略
7. for中range遍历
8. Go不允许使用无用的局部变量（_解决）
9. +=和strings.join
10. 四种声明var, const, type和func
11. :=和=
12. 元组赋值
13. 如果一个名字是大写字母开头的，那么该名字是导出
14. 声明语句的作用域是指源代码中可以有效使用这个名字的范围
15. 在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此 -5%3 和 -5%-3 结果都是-2；整数除法会向着0方向截断余数。
16. 虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的
17. r := [...]int{99: -1}

# 数据结构

## 数组

## 切片

1. 标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较。
2. slice不直接支持比较运算符，slice唯一合法的比较操作是和nil比较。
3. 如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。
4. append可以追加slice

## 哈希表

1. 无序

## 结构体

1. 如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的、
2. 匿名成员

# 语言基础

## 函数

1. Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。

# 内存管理

## 内存分配器

## 垃圾收集器

1. 虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。

## 栈内存管理

1. Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归
   时不必考虑溢出和安全问题。

# 其他

1. **栈上分配和堆上分配**

举例：defer

在 Go 中，内存分配可以发生在栈上或堆上，具体取决于分配的对象的大小和生命周期。

栈上分配是指将对象分配在调用栈上的内存空间。栈是一种存储函数调用和局部变量的内存区域，它的分配和释放是自动的，由编译器和运行时系统负责管理。栈上分配的对象生命周期与所属函数的执行周期相对应，当函数返回时，分配在栈上的对象会自动被释放。由于栈上分配和释放对象的代价较低，所以对于小型对象和临时变量来说，栈上分配是一种高效的内存管理方式。

堆上分配是指将对象分配在堆内存中。堆是一个动态分配的内存区域，存储的对象的生命周期可以超过函数的执行周期。堆上分配需要显式地进行内存分配和释放操作。Go 的垃圾回收器负责管理堆上的对象，并在不再被引用时自动回收这些对象的内存。对于较大的对象和长时间存活的对象来说，堆上分配是更合适的选择。

栈上分配和堆上分配的主要区别如下：

1. 分配速度：栈上分配更快，仅需移动栈指针即可完成分配，而堆上分配需要进行动态内存分配。
2. 生命周期：栈上分配的对象生命周期与所属函数的执行周期相对应，函数返回时自动释放，而堆上分配的对象的生命周期可以更长。
3. 空间限制：栈上分配的对象大小有限，一般受限于栈的大小，而堆上分配的对象大小没有限制。
4. 内存管理：栈上分配的对象由编译器和运行时系统自动管理，无需手动释放，而堆上分配的对象需要手动管理内存，或者由垃圾回收器自动回收。
5. 分配成本：栈上分配成本低，分配和释放都很快，而堆上分配成本较高，需要进行内存分配和垃圾回收操作。

在 Go 中，栈上分配和堆上分配的选择由编译器和运行时系统根据对象的大小和生命周期自动进行。开发人员无需显式指定分配方式，编写高效的代码应注重对象的作用域和生命周期，避免不必要的对象分配和内存占用。

2. **sudog**

在 Go 中，sudog（scheduling unit descriptor goroutine）是用于调度和管理协程（goroutine）的重要数据结构之一。它在运行时系统中起着关键的作用，用于协程的调度和同步。

~~~go
type sudog struct {
    g        *g               // 关联的协程
    isSelect bool             // 是否为 select 操作
    next     *sudog           // 链表中的下一个 sudog
    prev     *sudog           // 链表中的上一个 sudog
    elem     unsafe.Pointer   // 元素指针，用于存储等待操作的对象
    ...      // 其他字段，用于特定的调度和同步操作
}
~~~

sudog 结构的主要作用是实现等待操作，它可以被用于阻塞和唤醒协程，以及在调度器中维护等待队列

3. **调度器**

Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。

**基于协作的抢占式调度**：在基于协作的抢占式调度中，协程通过显式的协作点来释放执行权利。这些协作点通常是在某些关键的操作或代码位置，比如通信操作（如通道的发送和接收）、锁的获取和释放、休眠操作等。当一个协程到达协作点时，它会主动让出执行权利，让其他协程有机会执行。