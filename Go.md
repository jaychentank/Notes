# Go

1. **栈上分配和堆上分配**

举例：defer

在 Go 中，内存分配可以发生在栈上或堆上，具体取决于分配的对象的大小和生命周期。

栈上分配是指将对象分配在调用栈上的内存空间。栈是一种存储函数调用和局部变量的内存区域，它的分配和释放是自动的，由编译器和运行时系统负责管理。栈上分配的对象生命周期与所属函数的执行周期相对应，当函数返回时，分配在栈上的对象会自动被释放。由于栈上分配和释放对象的代价较低，所以对于小型对象和临时变量来说，栈上分配是一种高效的内存管理方式。

堆上分配是指将对象分配在堆内存中。堆是一个动态分配的内存区域，存储的对象的生命周期可以超过函数的执行周期。堆上分配需要显式地进行内存分配和释放操作。Go 的垃圾回收器负责管理堆上的对象，并在不再被引用时自动回收这些对象的内存。对于较大的对象和长时间存活的对象来说，堆上分配是更合适的选择。

栈上分配和堆上分配的主要区别如下：

1. 分配速度：栈上分配更快，仅需移动栈指针即可完成分配，而堆上分配需要进行动态内存分配。
2. 生命周期：栈上分配的对象生命周期与所属函数的执行周期相对应，函数返回时自动释放，而堆上分配的对象的生命周期可以更长。
3. 空间限制：栈上分配的对象大小有限，一般受限于栈的大小，而堆上分配的对象大小没有限制。
4. 内存管理：栈上分配的对象由编译器和运行时系统自动管理，无需手动释放，而堆上分配的对象需要手动管理内存，或者由垃圾回收器自动回收。
5. 分配成本：栈上分配成本低，分配和释放都很快，而堆上分配成本较高，需要进行内存分配和垃圾回收操作。

在 Go 中，栈上分配和堆上分配的选择由编译器和运行时系统根据对象的大小和生命周期自动进行。开发人员无需显式指定分配方式，编写高效的代码应注重对象的作用域和生命周期，避免不必要的对象分配和内存占用。

2. **sudog**

在 Go 中，sudog（scheduling unit descriptor goroutine）是用于调度和管理协程（goroutine）的重要数据结构之一。它在运行时系统中起着关键的作用，用于协程的调度和同步。

~~~go
type sudog struct {
    g        *g               // 关联的协程
    isSelect bool             // 是否为 select 操作
    next     *sudog           // 链表中的下一个 sudog
    prev     *sudog           // 链表中的上一个 sudog
    elem     unsafe.Pointer   // 元素指针，用于存储等待操作的对象
    ...      // 其他字段，用于特定的调度和同步操作
}
~~~

sudog 结构的主要作用是实现等待操作，它可以被用于阻塞和唤醒协程，以及在调度器中维护等待队列

3. **调度器**

Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。

**基于协作的抢占式调度**：在基于协作的抢占式调度中，协程通过显式的协作点来释放执行权利。这些协作点通常是在某些关键的操作或代码位置，比如通信操作（如通道的发送和接收）、锁的获取和释放、休眠操作等。当一个协程到达协作点时，它会主动让出执行权利，让其他协程有机会执行。