# Go

## 栈上分配和堆上分配

举例：defer

在 Go 中，内存分配可以发生在栈上或堆上，具体取决于分配的对象的大小和生命周期。

栈上分配是指将对象分配在调用栈上的内存空间。栈是一种存储函数调用和局部变量的内存区域，它的分配和释放是自动的，由编译器和运行时系统负责管理。栈上分配的对象生命周期与所属函数的执行周期相对应，当函数返回时，分配在栈上的对象会自动被释放。由于栈上分配和释放对象的代价较低，所以对于小型对象和临时变量来说，栈上分配是一种高效的内存管理方式。

堆上分配是指将对象分配在堆内存中。堆是一个动态分配的内存区域，存储的对象的生命周期可以超过函数的执行周期。堆上分配需要显式地进行内存分配和释放操作。Go 的垃圾回收器负责管理堆上的对象，并在不再被引用时自动回收这些对象的内存。对于较大的对象和长时间存活的对象来说，堆上分配是更合适的选择。

栈上分配和堆上分配的主要区别如下：

1. 分配速度：栈上分配更快，仅需移动栈指针即可完成分配，而堆上分配需要进行动态内存分配。
2. 生命周期：栈上分配的对象生命周期与所属函数的执行周期相对应，函数返回时自动释放，而堆上分配的对象的生命周期可以更长。
3. 空间限制：栈上分配的对象大小有限，一般受限于栈的大小，而堆上分配的对象大小没有限制。
4. 内存管理：栈上分配的对象由编译器和运行时系统自动管理，无需手动释放，而堆上分配的对象需要手动管理内存，或者由垃圾回收器自动回收。
5. 分配成本：栈上分配成本低，分配和释放都很快，而堆上分配成本较高，需要进行内存分配和垃圾回收操作。

在 Go 中，栈上分配和堆上分配的选择由编译器和运行时系统根据对象的大小和生命周期自动进行。开发人员无需显式指定分配方式，编写高效的代码应注重对象的作用域和生命周期，避免不必要的对象分配和内存占用。